\documentclass[japanese]{jssst_ppl} %% 日本語 (default)
% \documentclass[english]{jssst_ppl} %% English
% \documentclass[japanese,draft]{jssst_ppl} %% You can use the draft option
\usepackage{url}
\usepackage{listings}

\title{C言語ヘッダからのATS言語関数シグニチャの自動生成と段階的な線形型の導入}
\author{岡部 究$^1$}
\inst{%
$^1$ 理化学研究所 計算科学研究機構\\
\texttt{kiwamu@debian.or.jp}
}
\begin{document}
\lstset{ %
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  morekeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  tabsize=2,	                   % sets default tabsize to 2 spaces
}
\maketitle
\begin{abstract}
C言語を用いた低レベルなプログラミングにおいてメモリ破壊やリソースリークはやっかいな問題です。C言語の代替としてATS言語を採用し、線形型を用いてメモリアクセス権限やリソース生存範囲を表明することで、これらの違反をコンパイル時検査できることが知られています。しかし既存のC言語コード資産の上でATS言語実装を動かすには、当該C言語関数をATS言語にインポートする必要がありました。本論文では、この明らかに人為的なミスを誘発するプロセスをコード生成によって自動化するc2atsというツールを提案します。さらに、自動生成された関数シグニチャを使って危険なATSコードを作成した後、当該関数シグニチャに手動で線形型を導入することで、段階的にATSコードの安全性を向上できることを示します。
\end{abstract}

\section{はじめに}
近年プログラミング言語の進化はめざましく、ガベージコレクション/型推論/関数型プログラミングのような機能を備えた言語を用いて高い生産性でアプリケーションを作ることが可能になりました。しかし組み込み開発におけるハードウェアに近い領域でのプログラミングではC言語を用いた開発を余儀なくされています。C言語を用いた場合、その設計はバッファオーバフローのようなメモリ破壊やリソースリークのような不具合を容易にひきおこします。またC言語の機能は一般的な関数型言語よりも貧弱であり、代数的データ型のような今日一般的な機能でさえ使うことができません。

この大きな課題に対して様々な手法が提案されています。1つ目は静的コード解析\cite{Bessey:2010:FBL:1646353.1646374}と呼ばれる手法で、C言語コードをそのまま静的解析して不正なメモリ使用やリソースリークを防止します。しかしこのような解析器は多くのフォールスポジティブ(誤検知)やフォールスネガティブ(見逃し)を誘発してしまいます。またこの手法では設計基盤にC言語を使っているため、C言語と同等の型表現しか使うことができません。

2つ目はC言語のコード中に表明を手動で注入して、その表明を静的に検証する方法\cite{Frama-C}\cite{VeriFast}です。1つ目の手法と異なり、この手法を用いることでメモリの不正使用やリソースリークを正確に検出できます。しかし当然この手法でもC言語と同等の型表現しか使うことができません。

3つ目は低レベルプログラミング向けにC言語ではない新しい言語を導入する手法\cite{danish2015terrier}\cite{light2015reenix}です。その新しい言語の機能を使うことで、メモリの不正使用やリソースリークを正確に検出でき、さらに型推論やより豊かな型表現を使うことも可能になります。しかし既存のC言語資産と協調動作をする場合にはC言語関数を当該言語にインポートする必要があります。このインポートは主に手動で行なわれるため人為的なミスを誘発する可能性があります。

本論文では上記3つ目の手法の具体例としてATS言語を紹介した後、この手法が持つ問題点を解決するために当該インポートをコード生成によって自動化するc2atsというツールを提案します。このc2atsを用いて生成された関数シグニチャを使って危険なアプリケーションをATS言語で書いた後、当該関数シグニチャに手動で段階的に線形型を導入することで当該アプリケーションに発生しうるメモリの不正使用やリソースリークの危険性を除去することができることを示します。

\section{ATS言語概要}

ATS言語\cite{xi2003applied}\cite{ats}は静的型付けのプログラミング言語です。ATS言語のソースコードは拡張子 \verb|.sats| と \verb|.dats| の2つのファイルで構成されています。前者にはC言語の拡張子 \verb|.h| のヘッダファイルのように関数の宣言を格納し、後者にはC言語の拡張子 \verb|.c| のソースコードのように関数本体の定義を格納します。

ATS言語のプログラムの値にはML言語と同様に型がわりあてられており、値の性質を規定できます。その型は全称量化と存在量化で導入できる静的な値に依存することができ、その値の型は種と呼ばれます。さらに実体を持たない証明の値を持つこのもでき、その証明の型も通常の型と同様に静的な値に依存することができます。この両者からの依存によって、通常の値と証明の値を静的な値を通して結びつけることができます。

上記の証明とは具体的には次の2つです。1つ目は古典論理を用いたコードの証明で、ソートアルゴリズムの証明などに使うことができます。2つ目は線形論理を用いたリソースの追跡で、ポインタの生存範囲をコンパイル時に検査することができます。

ATS言語の関数定義には証明の変数と動的な変数があり、前者はコンパイル時でのみの検査のために使われ、後者はコンパイル後の実コードにそのまま使われます。同様に関数宣言にも証明の引数/動的な引数/証明の返り値/動的な返り値を取ることができます。例えばリスト\ref{proof_dynamic}のキーワード \verb|fun| で定義された関数は xxx

\begin{lstlisting}[caption=証明の引数と動的な引数,label=proof_dynamic]
xxx
\end{lstlisting}

さらに \verb|prfun| や \verb|praxi| キーワードを使うことで証明引数だけを取って証明返り値だけを返す関数を定義することもできます。

\section{線形型による安全なメモリ使用とリソースの追跡}

ATS言語では線形論理の命題を「観」と呼び、中でもメモリへのアクセス権限を表わす観を「駐観」と呼びます。種 \verb|addr| の静的な値アドレス \verb|l| があり、その静的なアドレスに依存したポインタの型が \verb|ptr(l)| であるとします。すると駐観 \verb|a@l| は当該アドレス \verb|l| に \verb|a| 型の値があることを意味しています。すなわち先のポインタの値はデリファレンスすることができ、\verb|a| 型の値を読み書きできることになります。もしそのコンテキストが \verb|l| に対する駐観を持たない場合、型 \verb|ptr(l)| のポインタはデリファレンスできません。

観や駐観は生成と消費ができます。

xxx 生成と消費について
xxx 観変化について

unsafe.satsというファイルをインクルードすると、(便利だけれど)危険なAPIを使うことが可能です。例えばその中で定義されている \verb|ptr_vtake| 関数はなんの証明もないポインタを取り、任意の駐観を返すキャスト関数です。

C言語では文字列は \verb|char *| 型として扱われますが、ATS言語ではリテラルとしての文字列であるstring型、線形型としての文字列であるstrptr型、静的な長さに依存した線形型の文字列であるstrnptr型という3種類の文字列型があります。

\section{C言語関数をATS言語から呼び出す}

C言語の関数をATS言語から呼び出す場合には当該関数に型を付けた上で、インポートする必要があります。

xxx

より詳しいATS言語の情報については''Introduction to Programming in ATS''\cite{INT2PROGINATS} (翻訳\cite{INT2PROGINATS-J}) を参照してください。

\section{c2ats概要}

前章でC言語関数をATS言語から呼び出せることがわかりましたが、そのインポートは手動で行なわれました。この手作業でのインポートにおいて人為的なミスがあった場合、どんなにATSコンパイラが正しく型検査したとしても、インポート元のC言語関数とインポートされたATS関数シグニチャの型が合わないために不具合が混入してしまいます。

そこで筆者はc2ats\cite{c2ats}というツールを開発中です。本章ではc2atsの詳細を解説する前にその使い方を通して概要を説明します。まずリスト\ref{example.h}のようなexample.hファイルがカレントディレクトリにあるとします。

\lstinputlisting[caption=example.hファイル,label=example.h]{example/hello/example.h}

このときコンソールからリスト\ref{c2ats-example.sats}のようにc2atsを実行することによってexample.satsファイルを自動生成できます。

\begin{lstlisting}[caption=example.satsの生成,label=c2ats-example.sats]
$ cd example/hello
$ c2ats gen example.h > example.sats
\end{lstlisting}

生成されたexample.satsファイルには先のexample.hからインクルードしていたstdio.h以下で宣言されている全ての関数がインポートされています。例えばC言語の \verb|printf| 関数はリスト\ref{imported-printf}のように自動的にexample.satsファイルにインポートされます。

\begin{lstlisting}[caption=自動インポートされたprintf関数,label=imported-printf]
$ vi example.sats
--snip--
viewdef ptr_v_1 (a:t@ype, l:addr) = a @ l
--snip--
fun fun_c2ats_printf: {l1:addr} (!ptr_v_1(char, l1) | ptr l1) -> int = "mac#printf"
--snip--
\end{lstlisting}

インポートされた \verb|printf| 関数には、既存のATSライブラリと干渉しないように、\verb|fun_c2ats_printf| という別名が付けられています。その第1引数は証明引数で、アドレス \verb|l1| に型 \verb|char| のデータがあること表明しています。通常の駐観の形式ではなく、\verb|ptr_v_1| という別名を使っているのは多段ポインタに対応するためですが、詳しくは次章で解説します。第2引数は実引数でポインタです。これら2つの引数は同時に \verb|l1| という静的な変数に依存していて、その種は \verb|addr| です。ATS言語ではC言語の可変長引数を扱う良い方法がないために、この \verb|fun_c2ats_printf| 関数は単に1つの文字列を印字することしかできません。

この \verb|fun_c2ats_printf| 関数を用いたATSコードをリスト\ref{main.dats}のように作ることができます。

\lstinputlisting[caption=main.datsファイル,label=main.dats]{example/hello/main.dats}

上記のmain.datsはコンソールからリスト\ref{}のようにATSコンパイラでコンパイルした後実行することができます。

\begin{lstlisting}[caption=main.datsのコンパイル,label=compile-main.dats]
$ cd example/hello
$ patscc -o test_prog main.dats
$ ./test_prog
Hello, world!
\end{lstlisting}

しかしリスト\ref{main.dats}のコードは以下の点で危険なコードです。

\begin{itemize}
\item 危険なAPIの入ったunsafe.satsをインポートしている
\item 何の証明もない単なるポインタから任意の駐観を取り出せる \verb|ptr_vtake| 関数を使っている
\end{itemize}

これらの問題は、c2atsがC言語のポインタをそのままに解釈してATSコードを生成した結果、自動生成された \verb|fun_c2ats_printf| 関数が \verb|char| への駐観を取るように定義されてしまっているために生じています。そこで、自動生成されたexample.satsをリスト\ref{string-printf}のように、\verb|fun_c2ats_printf| がATS言語の \verb|string| 型を取るように手動で修正してみます。

\begin{lstlisting}[caption=fun\_c2ats\_printf関数の引数をstringに,label=string-printf]
$ cp example.sats example_welltyped.sats
$ vi example_welltyped.sats
--snip--
fun fun_c2ats_printf: (string) -> int = "mac#printf"
--snip--
\end{lstlisting}

これでmain.datsをリスト\ref{safe-main.dats}のようにシンプルかつ安全に書き直すことができます。

\lstinputlisting[caption=より安全なmain.dats,label=safe-main.dats]{example/welltyped_hello/main.dats}

上記の新しいコードには先のような危険な問題はありません。このように、C言語とATS言語を協調させたプログラミングにおいて、c2atsが直接自動的にインポートした関数シグニチャはATSプログラマが真に欲しい型表現ではありません。これはc2atsがまだ開発途上であることにも原因がありますが、より大きな課題はC言語の関数定義がATS言語で使いたいレベルの不変条件を表明していないことに起因しています。このC言語における表明の不足については次章で具体的に解説します。

そのためc2atsの作るsatsファイルはRuby on Rails\cite{rails}のScaffoldのようなものだと考えることができます。c2atsで自動生成されたsatsファイルは手っ取り早くATSアプリケーションを作るための足場にすぎません。当該satsファイル内の関数シグニチャに問題があれば、手動でその型を強化すべきです。当該satsファイルは、決っして製品コードにそのまま無変更で採用されるべきではありません。そのsatsファイルは多くの危険なアプリケーション実装を誘発する関数シグニチャを含んでいるからです。しかしその危険性は元のC言語関数定義と同等のレベルです。

別の言い方をすると、元々危険であったC言語関数インターフェイスをc2atsによってATS言語に写像することで、ATSプログラマはその危険性をunsafe.satsなどの含む危険なキャストの使用という形で明確に知覚できるようになります。一旦知覚された危険性はATSプログラマがその危険なコードを手動除去する過程で自然に安全になります。結果自動生成されたsatsファイルの安全性を段階的に高めることが可能です。

\begin{table}[htb]
  \caption{ATS言語とC言語のプリミティブ型}
  \label{table:prim}
  \centering
  \begin{tabular}{l|l}
    C言語の型名 & ATS言語の型名 \\ \hline
    bool & bool \\
    char & char \\
    signed char & schar \\
    unsigned char & uchar \\
    short & sint \\
    unsigned short & usint \\
    int & int \\
    unsigned int & uint \\
    long int & lint \\
    unsigned long int & ulint \\
    long long int & llint \\
    unsigned long int & ullint \\
    float & float \\
    double & double \\
    long double & ldouble \\
  \end{tabular}
\end{table}

\section{c2atsによる自動生成ルール}

前章ではc2atsの使い方について説明しました。この時c2atsがC言語ヘッダからどのようなsatsファイルを生成するのか、そのルールを本章で説明します。また本論文では解説しませんが、構造体と構造体メンバーへのアクセサや関数ポインタもc2atsは自動変換します。

\subsection{プリミティブ型}

ATS言語のプリミティブ型はC言語の型と対応しています。表\ref{table:prim}にその対応を示します。c2atsはこの表にしたがってC言語のプリミティブ型をATS言語に写像します。

\subsection{関数宣言}

リスト\ref{func-on-c}のようなC言語の関数宣言があったとき、

\begin{lstlisting}[caption=C言語関数func\_a,label=func-on-c]
int func_a(int, char);
\end{lstlisting}

c2atsはリスト\ref{func-on-ats}のようなATSの関数宣言に変換します。

\begin{lstlisting}[caption=c2atsによって変換された関数func\_ac,label=func-on-ats]
fun fun_c2ats_func_a: (int, char) -> int = "mac#func_a"
\end{lstlisting}

生成された関数名には \verb|fun_c2ats_| という接頭辞が付けられます。\verb|=| の左辺においてはC言語からATS言語への単純な文法の変換です。\verb|"mac#func_a"| の部分には対応するC言語の関数名を指定します。この指定によって当該C言語関数をATS言語から呼び出し可能になります。

\subsection{ポインタ}

C言語のポインタをATS言語では \verb|ptr| 型として単に扱うこともできます。しかしこの方法ではポインタをC言語における \verb|void *| のように扱うために、危険であると言えます。そこでc2atsは全てのポインタに対する駐観を自動生成します。

例えば、リスト\ref{my-getopt-on-c}のようなC言語関数があるとき、

\begin{lstlisting}[caption=C言語関数my\_getopt,label=my-getopt-on-c]
int my_getopt (int, char **, char *);
\end{lstlisting}

c2atsはリスト\ref{my-getopt-on-ats}のようなATSの関数宣言に変換します。

\begin{lstlisting}[caption=c2atsによって変換された関数my\_getopt,label=my-getopt-on-ats]
fun fun_c2ats_my_getopt: {l1,l1_1,l2:addr} (!ptr_v_2(char, l1, l1_1), !ptr_v_1(char, l2) | int, ptr l1, ptr l2) -> int = "mac#my_getopt"
\end{lstlisting}

この時、型へのポインタを表わす駐観 \verb|ptr_v_1| と、型へのポインタのポインタを表わす駐観 \verb|ptr_v_2| と、型へのポインタのポインタのポインタを表わす駐観 \verb|ptr_v_3| はリスト\ref{at-view-on-c2ats}のように同時にsatsファイルに付随して出力されます。

\begin{lstlisting}[caption=c2atsにおける駐観の表現,label=at-view-on-c2ats]
viewdef ptr_v_1 (a:t@ype, l:addr) = a @ l
dataview ptr_v_2 (a:t@ype+, l0: addr, l1: addr) =
  | ptr_v_2_cons(a, l0, l1) of (ptr l1 @ l0, ptr_v_1 (a, l1))
dataview ptr_v_3 (a:t@ype+, l0:addr, l1:addr, l2:addr) =
  | ptr_v_3_cons(a, l0, l1, l2) of (ptr l1 @ l0, ptr_v_2 (a, l1, l2))
\end{lstlisting}

ATS言語では帰納的な駐観を作ることも可能ですが、c2atsでは依存するアドレスの範囲を別々に指定したい場合を想定して型宣言の外に依存したアドレス全てを見せています。すなわちこの方式を使って、先の \verb|my_getopt| 関数の変換結果において、リスト\ref{my-getopt-on-ats-nonull}のように種 \verb|agz| を用いて、1段目のポインタのアドレスである \verb|l1| と \verb|l2| のみがNULLではなく、2段目のポインタである \verb|l1_1| はNULLであることを許容するような型シグニチャを書くことができます。

\begin{lstlisting}[caption=一部のポインタにNULLを許容しないATS関数my\_getopt,label=my-getopt-on-ats-nonull]
fun fun_c2ats_my_getopt: {l1,l2:agz}{l1_1:addr} (!ptr_v_2(char, l1, l1_1), !ptr_v_1(char, l2) | int, ptr l1, ptr l2) -> int = "mac#my_getopt"
\end{lstlisting}

このようにc2atsはポインタがNULLであることを許容されうるかどうかを推測しません。c2atsは全てのポインタにはNULLが許容されるにもかかわらず、駐観があるものと見なすため、当該関数は当該ポインタを(NULLであるかもしれないにもかかわらず)デリファレンスできると想定していることになります。これはC言語と同等に危険です。

本来、C言語関数の実装者は引数の入出力や引数と返り値のポインタの関連などについて意図を持って設計したはずですが、その意図をc2atsがC言語ヘッダのみから読み取ることは困難です。

さらに、引数としての駐観はその依存する全てのアドレスを全称量化で導入し、さらに関数が返っても消費しません。また返り値としての駐観はその依存する全てのアドレスを存在量化で導入します。これはPOSIXの \verb|FCLOSE(3)| のように、実際には駐観を消費するであろう関数シグニチャでも同様です。これもまた本来はC言語設計者はポインタの生存区間を意図して設計したはずですが、その意図をc2atsがC言語ヘッダから読み取ることは困難です

そこでc2atsで出力されたsatsファイルを利用してATSプログラミムを書く際には、より強い型を手動で割り当てることが奨励されます。

\section{現実的なアプリケーション例: 自動生成された危険な関数の使用}

より現実的なアプリケーション例として「自分自身のソースコードを標準出力に印字するアプリケーション」を考えます。リスト\ref{real-example.h}のようなexample.hファイルがあるとします。

\lstinputlisting[caption=example.hファイル,label=real-example.h]{example/fileread/example.h}

このときコンソールからリスト\ref{real-example.sats}のようにexample.satsファイルを自動生成すると、その中には以下の関数がインポートされています。

\begin{lstlisting}[caption=example.satsの生成とその中身,label=real-example.sats]
$ c2ats gen example.h > example.sats
$ vi example.sats
--snip--
abst@ype struct_c2ats__IO_FILE // FIXME! Forward declaration.
typedef type_c2ats_FILE = struct_c2ats__IO_FILE
fun fun_c2ats_fclose: {l1:addr} (!ptr_v_1(type_c2ats_FILE, l1) | ptr l1) -> int = "mac#fclose"
fun fun_c2ats_fopen: {l1,l2:addr} (!ptr_v_1(char, l1), !ptr_v_1(char, l2) | ptr l1, ptr l2) -> [l3:addr] (ptr_v_1(type_c2ats_FILE, l3) | ptr l3) = "mac#fopen"
fun fun_c2ats_fread: {l1:addr} (!ptr_v_1(type_c2ats_FILE, l1) | ptr, type_c2ats_size_t, type_c2ats_size_t, ptr l1) -> type_c2ats_size_t = "mac#fread"
--snip--
\end{lstlisting}

上記の3つの関数 \verb|fun_c2ats_fopen|, \verb|fun_c2ats_fread|, \verb|fun_c2ats_fclose| を使うことで、アプリケーションをリスト\ref{real-main.dats}のように構築することができます。

\lstinputlisting[caption=main.datsファイル,label=real-main.dats]{example/fileread/main.dats}

上記のmain.datsファイルは自動生成したexample.satsファイルと共にコンパイルできますが、以下の点で危険なコードです。

\begin{itemize}
\item 危険性1: 危険なAPIの入ったunsafe.satsをインポートしている
\item 危険性2: 任意の駐観を消費できる \verb|__consume_view| という証明関数を定義して使っている
\item 危険性3: 何の証明もない単なるポインタから任意の駐観を取り出せる \verb|ptr_vtake| を使っている
\item 危険性4: \verb|fun_c2ats_fread| 関数が駐観も長さ情報も持たない生のポインタ \verb|buf_ptr| を取っている
\item 危険性5: 任意の型を任意の型にキャストできる \verb|cast| という関数を使っている
\item 危険性6: \verb|my_fread| 関数の返り値は静的な変数 \verb|m| に依存しているがその値の範囲は \verb|m <= n| であるべき
\end{itemize}

次の章では上記の危険性を取り除くことで、段階的に安全なATSコードが手に入る様子を観察します。

\section{現実的なアプリケーション例: 段階的な線形型の導入}

前章でのmain.datsとexample.satsを少しずつ修正して危険なコードを除去します。

\subsection{fun\_c2ats\_fopenがstring型を取るように}

危険性3は \verb|fun_c2ats_fopen| 関数が \verb|char| ポインタを引数に取るために当該ポインタのための駐観を作る必要性から生じたものです。そこで、リスト\ref{string_fun_c2ats_fopen}のように関数シグニチャを \verb|string| 型を取るように変更します。

\begin{lstlisting}[caption=string型を取るようにfun\_c2ats\_fopen関数を修正,label=string_fun_c2ats_fopen]
$ vi example.sats
--snip--
fun fun_c2ats_fopen: (string, string) -> [l3:addr] (ptr_v_1(type_c2ats_FILE, l3) | ptr l3) = "mac#fopen"
--snip--
\end{lstlisting}

これで \verb|fun_c2ats_fopen| 関数は引数を \verb|string| 型で取るようになりました。結果main.datsをリスト\ref{nouse_ptr_vtake}のように書き換えて、\verb|ptr_vtake| の使用を除去することができます。

\begin{lstlisting}[caption=ptr\_vtake関数を使わないようにmy\_fopen関数を修正,label=nouse_ptr_vtake]
$ vi main.dats
--snip--
fun my_fopen (file: string, mode: string):
    [l:agz] (type_c2ats_FILE@l | ptr(l)) = ret where {
  val (pffp | fp) = fun_c2ats_fopen(file, mode)
  val () = assertloc(fp > 0)
  val ret = (pffp | fp)
}
--snip--
\end{lstlisting}

\subsection{fun\_c2ats\_fcloseで駐観を消費}

危険性2は \verb|fun_c2ats_fclose| 関数が返った後でもファイルポインタの駐観 \verb|pffp| が消費されないために発生していました。C言語の関数定義からは直接解釈することはできませんが、\verb|fclose| の定義では一度クローズしたファイルポインタは使用不能になるはずです。そのため \verb|fun_c2ats_fclose| は当該の駐観を消費すべきです。そこで関数シグニチャをリスト\ref{consume_fun_c2ats_fclose}のように修正します。

\begin{lstlisting}[caption=駐観を消費するようにfun\_c2ats\_fclose関数を修正,label=consume_fun_c2ats_fclose]
$ vi example.sats
--snip--
fun fun_c2ats_fclose: {l1:agz} (ptr_v_1(type_c2ats_FILE, l1) | ptr l1) -> int = "mac#fclose"
--snip--
\end{lstlisting}

また同時に \verb|fclose| するファイルポインタは非NULLであることが望ましいので、上記修正では当該ファイルポインタが依存している静的なアドレスの種を非NULLである \verb|agz| に設定しています。

すると、リスト\ref{nouse_consume_view}のように \verb|__consume_view| 関数の使用が不要になり、\verb|main0| 関数から直接 \verb|fun_c2ats_fclose| 関数を呼び出せるようになります。

\begin{lstlisting}[caption=\_\_consume\_view関数を使わないようにmain0関数を修正,label=nouse_consume_view]
$ vi main.dats
--snip--
implement main0 () = {
  val (pffp | fp) = my_fopen("main.dats", "r")
  val () = readshow(pffp | fp)
  val r = fun_c2ats_fclose(pffp | fp)
}
--snip--
\end{lstlisting}

\subsection{fun\_c2ats\_freadがstrnptr型を取るように}

危険性4を修正するために \verb|buf_ptr| の元になった、\verb|string_tabulate| 関数で確保した、長さ情報を静的に持つ \verb|strnptr| 型の値を直接 \verb|fun_c2ats_fread| 関数に渡せるように、リスト\ref{strnptr_fun_c2ats_fread}関数シグニチャを修正します。

\begin{lstlisting}[caption=strnptr型を使うようにfun\_c2ats\_fread関数を修正,label=strnptr_fun_c2ats_fread]
$ vi example.sats
--snip--
fun fun_c2ats_fread: {l1:agz}{m:nat} (!ptr_v_1(type_c2ats_FILE, l1) | !strnptr(m)>>strnptr(o), type_c2ats_size_t, type_c2ats_size_t, ptr l1) -> #[o:nat | o <= m] size_t(o) = "mac#fread"
--snip--
\end{lstlisting}

上記の修正では \verb|fun_c2ats_fread| 関数の第1実引数に \verb|strnptr(m)| 型を渡し、この関数が返る時にはその型が \verb|strnptr(o)| であることを表明しています。ただし、このとき \verb|o| は \verb|o <= m| にならなければなりません。またこの関数の返り値も \verb|o| に依存しています。つまり \verb|fread| した後のバッファの長さはその返り値と等しいことが期待されています。

また同時に \verb|fread| するファイルポインタは非NULLであることが望ましいので、上記修正では当該ファイルポインタが依存している静的なアドレスを非NULLである \verb|agz| に設定しています。

するとリスト\ref{strnptr_my_fread}のように \verb|my_fread| 関数を修正して、\verb|fun_c2ats_fread| 関数に直接 \verb|strnptr| 型を渡せるようになります。

\begin{lstlisting}[caption=strnptr型を使うようにmy\_fread関数を修正,label=strnptr_my_fread]
$ vi main.dats
--snip--
fun my_fread {l:agz}{n:nat}
    (pffp: !type_c2ats_FILE@l | fp: ptr(l), len: size_t(n)):
    [m:int] (size_t(m), strnptr(m)) = ret where {
  implement{} string_tabulate$fopr(s) = '_'
  val buf_strnptr = string_tabulate(len)
  val buf_ptr = strnptr2ptr(buf_strnptr)
  val _ = $STRING.memset_unsafe(buf_ptr, 0, len)

  val r = fun_c2ats_fread(pffp | buf_strnptr, 1UL, $UN.cast2ulint(len), fp)
  val ret = (r, buf_strnptr)
}
--snip--
\end{lstlisting}

このとき、返り値と \verb|buf_strnptr| が依存する静的な長さと返り値 \verb|r| が依存する静的な長さが一致するので、\verb|cast| による危険なキャストも不要になり、危険性5も解消することができました。

\subsection{fun\_c2ats\_freadでsize\_t型を使う}

危険性6を解消するために、リスト\ref{size_t_fun_c2ats_fread}のように \verb|fun_c2ats_fread| 関数の引数を \verb|size_t| 型にして、さらにその値の範囲を明示します。

\begin{lstlisting}[caption=size\_t型を使うようにfun\_c2ats\_fread関数を修正,label=size_t_fun_c2ats_fread]
$ vi example.sats
--snip--
fun fun_c2ats_fread: {l1:agz}{n,m:nat} (!ptr_v_1(type_c2ats_FILE, l1) | !strnptr(n*m)>>strnptr(o), size_t(n), size_t(m), ptr l1) -> #[o:nat | o <= n*m] size_t(o) = "mac#fread"
--snip--
\end{lstlisting}

静的な変数 \verb|n| と \verb|m| を全称量化で導入し、その値は0以上です。\verb|fun_c2ats_fread| 関数の第2実引数と第3実引数はそれぞれ \verb|n| と \verb|m| に依存し、さらに第1実引数である \verb|strnptr| 型の文字列は当該関数の呼び出し前は \verb|n*m| の長さです。本関数が呼び出された後では、\verb|strnptr| 型の文字列の長さと \verb|size_t| 型の返り値の値は \verb|o| で、その範囲は \verb|p <= n*m| です。

するとリスト\ref{better_my_fread}のように \verb|my_fread| 関数を修正して、当該関数の返り値である \verb|size_t| と \verb|strnptr| 型の文字列に \verb|m <= n| という制約をつけれるようになります。

\begin{lstlisting}[caption=より強い制約をmy\_fread関数に与える,label=better_my_fread]
$ vi main.dats
fun my_fread {l:agz}{n:nat}
    (pffp: !type_c2ats_FILE@l | fp: ptr(l), len: size_t(n)):
    [m:nat | m <= n] (size_t(m), strnptr(m)) = ret where {
  implement{} string_tabulate$fopr(s) = '_'
  val buf_strnptr = string_tabulate(len)
  val buf_ptr = strnptr2ptr(buf_strnptr)
  val _ = $STRING.memset_unsafe(buf_ptr, 0, len)

  val r = fun_c2ats_fread(pffp | buf_strnptr, i2sz(1), len, fp)
  val ret = (r, buf_strnptr)
}
\end{lstlisting}

さらにもはやunsafe.satsのインポートも不要になり、危険性1も解消することができました。

\section{現実的なアプリケーション例: 安全になった関数シグニチャ}

前章による段階的なコード修正によって、リスト\ref{safe_main.dats}のようにより安全なアプリケーションが構築できました。

\lstinputlisting[caption=より安全なmain.dats,label=safe_main.dats]{example/welltyped_fileread/main.dats}

また、上記のアプリケーションはリスト\ref{safe_example.sats}のsatsファイル中のより安全な関数シグニチャを使います。

\begin{lstlisting}[caption=より安全なexample.sats,label=safe_example.sats]
$ vi example_welltyped.sats
--snip--
abst@ype struct_c2ats__IO_FILE // FIXME! Forward declaration.
typedef type_c2ats_FILE = struct_c2ats__IO_FILE
fun fun_c2ats_fclose: {l1:agz} (ptr_v_1(type_c2ats_FILE, l1) | ptr l1) -> int = "mac#fclose"
fun fun_c2ats_fopen: (string, string) -> [l3:addr] (ptr_v_1(type_c2ats_FILE, l3) | ptr l3) = "mac#fopen"
fun fun_c2ats_fread: {l1:agz}{n,m:nat} (!ptr_v_1(type_c2ats_FILE, l1) | !strnptr(n*m)>>strnptr(o), size_t(n), size_t(m), ptr l1) -> #[o:nat | o <= n*m] size_t(o) = "mac#fread"
--snip--
\end{lstlisting}

このコードからは先の危険性1-5の全てを排除されています。

\section{制限と今後}

c2atsはまだ開発途上のために以下いくつか制限があります。

\begin{enumerate}
\item 単一のsatsファイルしか出力できません。大きなプログラムを扱う場合にはモジュール毎にsatsファイルを分割してインクルードしたい要求があります。
\item C言語の前方宣言をATS言語に上手く写像できません。C言語では中身の定義のない構造体を宣言した後、後続でその構造体へのポインタを使用し、さらにその後で実際の当該構造体の中身を定義することが可能でした。ところがATS言語ではこのような前方宣言を行なうことができません。現状は前方宣言に対応するATSコードとして同名の抽象データ型宣言を挿入することでコンパイル可能にしています。
\item C言語の関数宣言ではなく関数本体をATS言語に翻訳できません。
\item ATS言語で共用体を構造体と同様に扱うのは明らかに危険です。代数データ型を使うべきです。
\item \verb|const| などの特殊な修飾子やビットフィールドなどにはATS言語に等価な表現がありません。
\end{enumerate}

これらの制約の内、1,2,3については以下のように今後のc2atsの開発で解消できると考えます。

\begin{enumerate}
\item ATS言語の宣言がどのC言語ヘッダで宣言されていたか調べることで、C言語ヘッダと同じ構造のsatsファイル群を出力する機能を作成中です。
\item 前方宣言をできうるかぎりATS言語で宣言できる順序に整列します。整列できなかった前方宣言は本質的に循環しているため、手動で翻訳する必要があります。
\item gotoのないC言語コードは原理的にはATS言語に翻訳可能です。しかしgotoを含むC言語コードは例外のないATS言語コードに翻訳するにはなんらかのモデルが必要です。つまりgotoの用法をいくつかのモデル(大域脱出、リトライ、など)に分類した上で対応するATS言語のイディオムに変換することが可能かもしれません。
\end{enumerate}

残る制限については上記が解消した後、ATSコンパイラ原作者と協議の上対応策を決定する予定です。

\section{関連研究}

c2atsはC言語から高級言語を作成する唯一のプロジェクトではありません。c2hs\cite{c2hs}はC言語のヘッダファイルとchsファイルという注釈入りのHaskellコードからHaskellのFFI定義を自動生成します。c2atsと異なり、chsファイルで注釈された対象のC言語コードに対してのみFFIを生成するために効率的であると言えます。大きなC言語コードの一部をATSコード化したい場合にはc2hsのような「興味のある対象だけを切り取って変換」する機能が必要でしょう。

corrode\cite{corrode}はC言語のヘッダファイルやソースファイルを入力としてRust言語のソースコードを出力します。このツールはC言語関数本体もRust言語に変換するため、c2atsはこれを将来の機能拡張の手本とすることができます。一方、Rust言語にはATS言語がそなえる依存型を持たないため、Rust言語に変換したコードの正確さを手動で強化しにくいでしょう。

\section{結論}

比較的単純な変換ルールを決めることで、C言語ヘッダ中の宣言をATS言語の宣言(satsファイル)に自動的翻訳することが可能であることを示しました。自動変換されたsatsファイルを使って型キャストを用いた危険なATS言語アプリケーションを作成できることを示しました。そのsatsファイルと危険なアプリケーションに段階的に線形型を導入することで、より安全な関数シグニチャとアプリケーションが手に入ることを示しました。最後に本ツールの現状での制限と開発計画を展望しました。

\section*{謝辞}
language-cという素晴しいライブラリを紹介してくれた村主崇行氏と、C言語の型表現をいかにしてATS言語の型表現に解釈しなおすか根気強いサポートをしてくれたHongwei Xiに感謝します。

% BibTeX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{../bibtex/reference,../bibtex/jreference}

\end{document}
